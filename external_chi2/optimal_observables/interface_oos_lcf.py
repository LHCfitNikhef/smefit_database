import numpy as np
import pathlib
import jax.numpy as jnp
from smefit import log
from smefit.rge.rge import RGE, load_precomputed_rge_matrix, load_rge_mats_from_scales
from smefit.coefficients import CoefficientManager

current_file_path = pathlib.Path(__file__).resolve().parent

oo_ww_wc_basis = ["OpD", "OpWB", "OWWW", "Opl1", "Ope", "O3pl1"]
oo_tt_wc_basis = ["OpQM", "Opt", "OtW", "OtZ", "OQl1M", "OQe", "Otl1", "Ote"]

_logger = log.logging.getLogger(__name__)


# function to compute the RGE matrix at scale
def compute_rge_matrix(coefficients, rge_dict, scale):
    """
    Compute the RGE solution at the scale `scale` and return it as an array.
    It also returns an updated list of coefficients that includes the new operators generated by the RGE.
    """
    if type(rge_dict["obs_scale"]) == float:
        low_scale = rge_dict["obs_scale"]
    else:
        low_scale = scale
    rge_runner = RGE(
        wc_names=coefficients.name,
        init_scale=rge_dict["init_scale"],
        accuracy=rge_dict.get("smeft_accuracy", "integrate"),
        adm_QCD=rge_dict.get("adm_QCD", False),
        yukawa=rge_dict.get("yukawa", "top"),
    )
    rge_df = rge_runner.RGEmatrix(low_scale)
    gen_operators = list(rge_df.index)
    _logger.info("The operators generated by the RGE are: ")
    _logger.info(gen_operators)
    operators_dict = {k: {"max": 0.0, "min": 0.0} for k in gen_operators}
    new_coeffs = CoefficientManager.from_dict(operators_dict)

    return rge_df.values, new_coeffs


# function that manages the inclusion og the RGE matrix in the optimal observables classes. It returns the RGE matrix and the updated coefficients.
# It decides if the RGE matrix should be computed or loaded from a precomputed file based on the rge_dict input.
def rge_matrix_manager(coefficients, rge_dict, scale):
    """
    Manage the inclusion of the RGE matrix in the optimal observables classes.
    It returns the RGE matrix and the updated coefficients.
    It decides if the RGE matrix should be computed or loaded from a precomputed file based on the rge_dict input.
    If the RGE dictionary includes a float as the "obs_scale", it ignores the scale input and uses the "obs_scale"
    as the scale at which to compute the RGE matrix.
    If "obs_scale" is a float, it also checks if there is a precomputed RGE matrix for that scale and loads it if it exists, otherwise it computes the RGE matrix and returns it.
    If "obs_scale" is not a float, it computes the RGE matrix at the scale input and returns it.
    Future improvements should include the possibility to load precomputed RGE matrices for the case of dynamical scales.
    """
    if rge_dict is not None:
        # need for the RGE. Initializes the runner.
        rge_runner = RGE(
            wc_names=coefficients.name,
            init_scale=rge_dict["init_scale"],
            accuracy=rge_dict["smeft_accuracy"],
            adm_QCD=rge_dict["adm_QCD"],
            yukawa=rge_dict["yukawa"],
        )
        # checks if the obs_scale is a float. If it is, it uses that as the scale at which to compute the RGE matrix
        if type(rge_dict["obs_scale"]) == float:
            # check if there is a precomputed RGE matrix address.
            path_to_rge_mat = rge_dict.get("rg_matrix", False)
            low_scale = rge_dict["obs_scale"]
            rge_cache = {}
            if path_to_rge_mat:
                # if there is a precomputed RGE matrix, it loads it with the internal smefit function.
                rge_cache = load_precomputed_rge_matrix(
                    path_to_rge_mat,
                    {
                        "init_scale": rge_dict["init_scale"],
                        "smeft_accuracy": rge_dict["smeft_accuracy"],
                        "adm_QCD": rge_dict["adm_QCD"],
                        "yukawa": rge_dict["yukawa"],
                    },
                )

            # uses the internal smefit function to select from the (possibly) precomputed RGE matrix or compute it  if needed.
            pre_rgemat = load_rge_mats_from_scales(
                [low_scale], coefficients.name, rge_runner, rge_cache
            )

            # array of values to return
            rgemat = (pre_rgemat[0]).values

            # updates the list of coefficients with the ones generated by the RGE.
            # piece of code shared with the compute_rge_matrix function, should be refactored in a future update to avoid code duplication.
            gen_operators = list((pre_rgemat[0]).index)
            _logger.info("The operators generated by the RGE are: ")
            _logger.info(gen_operators)
            operators_dict = {k: {"max": 0.0, "min": 0.0} for k in gen_operators}
            new_coeffs = CoefficientManager.from_dict(operators_dict)

        else:
            # assumes that the scale input is dynamica and hence the RGE should be computed at the right scale for the OOs, which is an input.
            low_scale = scale
            rgemat, new_coeffs = compute_rge_matrix(
                coefficients, rge_dict, scale=low_scale
            )
    else:
        rgemat = None

    return rgemat, new_coeffs


class OptimalWWLCF250:
    def __init__(self, coefficients, rge_dict=None):
        self.rgemat, coefficients = rge_matrix_manager(
            coefficients, rge_dict, scale=250.0
        )

        self.project = np.zeros((len(oo_ww_wc_basis), coefficients.size))
        for i, op in enumerate(oo_ww_wc_basis):
            if op in coefficients.name:
                self.project[i, np.argwhere(coefficients.name == op)[0, 0]] = 1

        self.datasets = {
            "LCF_ww_lepto_250_neg80_neg30": "invcov_LCF_ww_leptonic_250_neg80_neg30.dat",
            "LCF_ww_lepto_250_neg80_pos30": "invcov_LCF_ww_leptonic_250_neg80_pos30.dat",
            "LCF_ww_lepto_250_pos80_neg30": "invcov_LCF_ww_leptonic_250_pos80_neg30.dat",
            "LCF_ww_lepto_250_pos80_pos30": "invcov_LCF_ww_leptonic_250_pos80_pos30.dat",
            "LCF_ww_semilep_250_neg80_neg30": "invcov_LCF_ww_semilep_250_neg80_neg30.dat",
            "LCF_ww_semilep_250_neg80_pos30": "invcov_LCF_ww_semilep_250_neg80_pos30.dat",
            "LCF_ww_semilep_250_pos80_neg30": "invcov_LCF_ww_semilep_250_pos80_neg30.dat",
            "LCF_ww_semilep_250_pos80_pos30": "invcov_LCF_ww_semilep_250_pos80_pos30.dat",
        }

        incovs_reordered = []
        for path in self.datasets.values():
            invcov = np.loadtxt(current_file_path / path)
            temp = jnp.einsum("ij, jk, kl", self.project.T, invcov, self.project)
            incovs_reordered.append(temp)
        self.incov_tot = jnp.sum(jnp.array(incovs_reordered), axis=0)

        if self.rgemat is not None:
            # multiply the RGE matrix as well
            self.incov_tot = jnp.einsum(
                "ij, jk, kl", self.rgemat.T, self.incov_tot, self.rgemat
            )

        self.n_dat = len(oo_ww_wc_basis)

    def compute_chi2(self, coefficient_values):
        chi2_value = jnp.einsum(
            "i, ij, j", coefficient_values, self.incov_tot, coefficient_values
        )

        return chi2_value


class OptimalWWLCF5004ab:
    def __init__(self, coefficients, rge_dict=None):
        self.rgemat, coefficients = rge_matrix_manager(
            coefficients, rge_dict, scale=500.0
        )

        self.project = np.zeros((len(oo_ww_wc_basis), coefficients.size))
        for i, op in enumerate(oo_ww_wc_basis):
            if op in coefficients.name:
                self.project[i, np.argwhere(coefficients.name == op)[0, 0]] = 1

        self.datasets = {
            "LCF_ww_lepto_500_4ab_neg80_neg30": "invcov_LCF_ww_leptonic_500_4ab_neg80_neg30.dat",
            "LCF_ww_lepto_500_4ab_neg80_pos30": "invcov_LCF_ww_leptonic_500_4ab_neg80_pos30.dat",
            "LCF_ww_lepto_500_4ab_pos80_neg30": "invcov_LCF_ww_leptonic_500_4ab_pos80_neg30.dat",
            "LCF_ww_lepto_500_4ab_pos80_pos30": "invcov_LCF_ww_leptonic_500_4ab_pos80_pos30.dat",
            "LCF_ww_semilep_500_4ab_neg80_neg30": "invcov_LCF_ww_semilep_500_4ab_neg80_neg30.dat",
            "LCF_ww_semilep_500_4ab_neg80_pos30": "invcov_LCF_ww_semilep_500_4ab_neg80_pos30.dat",
            "LCF_ww_semilep_500_4ab_pos80_neg30": "invcov_LCF_ww_semilep_500_4ab_pos80_neg30.dat",
            "LCF_ww_semilep_500_4ab_pos80_pos30": "invcov_LCF_ww_semilep_500_4ab_pos80_pos30.dat",
        }

        incovs_reordered = []
        for path in self.datasets.values():
            invcov = np.loadtxt(current_file_path / path)
            temp = jnp.einsum("ij, jk, kl", self.project.T, invcov, self.project)
            incovs_reordered.append(temp)
        self.incov_tot = jnp.sum(jnp.array(incovs_reordered), axis=0)

        if self.rgemat is not None:
            # multiply the RGE matrix as well
            self.incov_tot = jnp.einsum(
                "ij, jk, kl", self.rgemat.T, self.incov_tot, self.rgemat
            )

        self.n_dat = len(oo_ww_wc_basis)

    def compute_chi2(self, coefficient_values):
        chi2_value = jnp.einsum(
            "i, ij, j", coefficient_values, self.incov_tot, coefficient_values
        )

        return chi2_value


class OptimalWWLCF5008ab:
    def __init__(self, coefficients, rge_dict=None):
        self.rgemat, coefficients = rge_matrix_manager(
            coefficients, rge_dict, scale=500.0
        )

        self.project = np.zeros((len(oo_ww_wc_basis), coefficients.size))
        for i, op in enumerate(oo_ww_wc_basis):
            if op in coefficients.name:
                self.project[i, np.argwhere(coefficients.name == op)[0, 0]] = 1

        self.datasets = {
            "LCF_ww_lepto_500_8ab_neg80_neg30": "invcov_LCF_ww_leptonic_500_8ab_neg80_neg30.dat",
            "LCF_ww_lepto_500_8ab_neg80_pos30": "invcov_LCF_ww_leptonic_500_8ab_neg80_pos30.dat",
            "LCF_ww_lepto_500_8ab_pos80_neg30": "invcov_LCF_ww_leptonic_500_8ab_pos80_neg30.dat",
            "LCF_ww_lepto_500_8ab_pos80_pos30": "invcov_LCF_ww_leptonic_500_8ab_pos80_pos30.dat",
            "LCF_ww_semilep_500_8ab_neg80_neg30": "invcov_LCF_ww_semilep_500_8ab_neg80_neg30.dat",
            "LCF_ww_semilep_500_8ab_neg80_pos30": "invcov_LCF_ww_semilep_500_8ab_neg80_pos30.dat",
            "LCF_ww_semilep_500_8ab_pos80_neg30": "invcov_LCF_ww_semilep_500_8ab_pos80_neg30.dat",
            "LCF_ww_semilep_500_8ab_pos80_pos30": "invcov_LCF_ww_semilep_500_8ab_pos80_pos30.dat",
        }

        incovs_reordered = []
        for path in self.datasets.values():
            invcov = np.loadtxt(current_file_path / path)
            temp = jnp.einsum("ij, jk, kl", self.project.T, invcov, self.project)
            incovs_reordered.append(temp)
        self.incov_tot = jnp.sum(jnp.array(incovs_reordered), axis=0)

        if self.rgemat is not None:
            # multiply the RGE matrix as well
            self.incov_tot = jnp.einsum(
                "ij, jk, kl", self.rgemat.T, self.incov_tot, self.rgemat
            )

        self.n_dat = len(oo_ww_wc_basis)

    def compute_chi2(self, coefficient_values):
        chi2_value = jnp.einsum(
            "i, ij, j", coefficient_values, self.incov_tot, coefficient_values
        )

        return chi2_value


class OptimalWWLCF1000:
    def __init__(self, coefficients, rge_dict=None):
        self.rgemat, coefficients = rge_matrix_manager(
            coefficients, rge_dict, scale=1000.0
        )

        self.project = np.zeros((len(oo_ww_wc_basis), coefficients.size))
        for i, op in enumerate(oo_ww_wc_basis):
            if op in coefficients.name:
                self.project[i, np.argwhere(coefficients.name == op)[0, 0]] = 1

        self.datasets = {
            "LCF_ww_lepto_1000_neg80_neg20": "invcov_LCF_ww_leptonic_1000_neg80_neg20.dat",
            "LCF_ww_lepto_1000_neg80_pos20": "invcov_LCF_ww_leptonic_1000_neg80_pos20.dat",
            "LCF_ww_lepto_1000_pos80_neg20": "invcov_LCF_ww_leptonic_1000_pos80_neg20.dat",
            "LCF_ww_lepto_1000_pos80_pos20": "invcov_LCF_ww_leptonic_1000_pos80_pos20.dat",
            "LCF_ww_semilep_1000_neg80_neg20": "invcov_LCF_ww_semilep_1000_neg80_neg20.dat",
            "LCF_ww_semilep_1000_neg80_pos20": "invcov_LCF_ww_semilep_1000_neg80_pos20.dat",
            "LCF_ww_semilep_1000_pos80_neg20": "invcov_LCF_ww_semilep_1000_pos80_neg20.dat",
            "LCF_ww_semilep_1000_pos80_pos20": "invcov_LCF_ww_semilep_1000_pos80_pos20.dat",
        }

        incovs_reordered = []
        for path in self.datasets.values():
            invcov = np.loadtxt(current_file_path / path)
            temp = jnp.einsum("ij, jk, kl", self.project.T, invcov, self.project)
            incovs_reordered.append(temp)
        self.incov_tot = jnp.sum(jnp.array(incovs_reordered), axis=0)

        if self.rgemat is not None:
            # multiply the RGE matrix as well
            self.incov_tot = jnp.einsum(
                "ij, jk, kl", self.rgemat.T, self.incov_tot, self.rgemat
            )

        self.n_dat = len(oo_ww_wc_basis)

    def compute_chi2(self, coefficient_values):
        chi2_value = jnp.einsum(
            "i, ij, j", coefficient_values, self.incov_tot, coefficient_values
        )

        return chi2_value


class OptimalttLCF350:
    def __init__(self, coefficients, rge_dict=None):
        self.rgemat, coefficients = rge_matrix_manager(
            coefficients, rge_dict, scale=350.0
        )

        self.project = np.zeros((len(oo_tt_wc_basis), coefficients.size))
        for i, op in enumerate(oo_tt_wc_basis):
            if op in coefficients.name:
                self.project[i, np.argwhere(coefficients.name == op)[0, 0]] = 1

        self.datasets = {
            "LCF_tt_wbwb_350_neg80_neg30": "invcov_LCF_tt_wbwb_350_neg80_neg30.dat",
            "LCF_tt_wbwb_350_pos80_neg30": "invcov_LCF_tt_wbwb_350_pos80_neg30.dat",
            "LCF_tt_wbwb_350_neg80_pos30": "invcov_LCF_tt_wbwb_350_neg80_pos30.dat",
            "LCF_tt_wbwb_350_pos80_pos30": "invcov_LCF_tt_wbwb_350_pos80_pos30.dat",
        }

        incovs_reordered = []
        for path in self.datasets.values():
            invcov = np.loadtxt(current_file_path / path)
            temp = jnp.einsum("ij, jk, kl", self.project.T, invcov, self.project)
            incovs_reordered.append(temp)
        self.incov_tot = jnp.sum(jnp.array(incovs_reordered), axis=0)

        if self.rgemat is not None:
            # multiply the RGE matrix as well
            self.incov_tot = jnp.einsum(
                "ij, jk, kl", self.rgemat.T, self.incov_tot, self.rgemat
            )

        self.n_dat = len(oo_tt_wc_basis)

    def compute_chi2(self, coefficient_values):
        chi2_value = jnp.einsum(
            "i, ij, j", coefficient_values, self.incov_tot, coefficient_values
        )

        return chi2_value


class OptimalttLCF5004ab:
    def __init__(self, coefficients, rge_dict=None):
        self.rgemat, coefficients = rge_matrix_manager(
            coefficients, rge_dict, scale=500.0
        )

        self.project = np.zeros((len(oo_tt_wc_basis), coefficients.size))
        for i, op in enumerate(oo_tt_wc_basis):
            if op in coefficients.name:
                self.project[i, np.argwhere(coefficients.name == op)[0, 0]] = 1

        self.datasets = {
            "LCF_tt_wbwb_500_4ab_neg80_neg30": "invcov_LCF_tt_wbwb_500_4ab_neg80_neg30.dat",
            "LCF_tt_wbwb_500_4ab_pos80_neg30": "invcov_LCF_tt_wbwb_500_4ab_pos80_neg30.dat",
            "LCF_tt_wbwb_500_4ab_neg80_pos30": "invcov_LCF_tt_wbwb_500_4ab_neg80_pos30.dat",
            "LCF_tt_wbwb_500_4ab_pos80_pos30": "invcov_LCF_tt_wbwb_500_4ab_pos80_pos30.dat",
        }

        incovs_reordered = []
        for path in self.datasets.values():
            invcov = np.loadtxt(current_file_path / path)
            temp = jnp.einsum("ij, jk, kl", self.project.T, invcov, self.project)
            incovs_reordered.append(temp)
        self.incov_tot = jnp.sum(jnp.array(incovs_reordered), axis=0)

        if self.rgemat is not None:
            # multiply the RGE matrix as well
            self.incov_tot = jnp.einsum(
                "ij, jk, kl", self.rgemat.T, self.incov_tot, self.rgemat
            )

        self.n_dat = len(oo_tt_wc_basis)

    def compute_chi2(self, coefficient_values):
        chi2_value = jnp.einsum(
            "i, ij, j", coefficient_values, self.incov_tot, coefficient_values
        )

        return chi2_value


class OptimalttLCF5008ab:
    def __init__(self, coefficients, rge_dict=None):
        self.rgemat, coefficients = rge_matrix_manager(
            coefficients, rge_dict, scale=500.0
        )

        self.project = np.zeros((len(oo_tt_wc_basis), coefficients.size))
        for i, op in enumerate(oo_tt_wc_basis):
            if op in coefficients.name:
                self.project[i, np.argwhere(coefficients.name == op)[0, 0]] = 1

        self.datasets = {
            "LCF_tt_wbwb_500_8ab_neg80_neg30": "invcov_LCF_tt_wbwb_500_8ab_neg80_neg30.dat",
            "LCF_tt_wbwb_500_8ab_pos80_neg30": "invcov_LCF_tt_wbwb_500_8ab_pos80_neg30.dat",
            "LCF_tt_wbwb_500_8ab_neg80_pos30": "invcov_LCF_tt_wbwb_500_8ab_neg80_pos30.dat",
            "LCF_tt_wbwb_500_8ab_pos80_pos30": "invcov_LCF_tt_wbwb_500_8ab_pos80_pos30.dat",
        }

        incovs_reordered = []
        for path in self.datasets.values():
            invcov = np.loadtxt(current_file_path / path)
            temp = jnp.einsum("ij, jk, kl", self.project.T, invcov, self.project)
            incovs_reordered.append(temp)
        self.incov_tot = jnp.sum(jnp.array(incovs_reordered), axis=0)

        self.rgemat = rgemat

        if self.rgemat is not None:
            # multiply the RGE matrix as well
            self.incov_tot = jnp.einsum(
                "ij, jk, kl", self.rgemat.T, self.incov_tot, self.rgemat
            )

        self.n_dat = len(oo_tt_wc_basis)

    def compute_chi2(self, coefficient_values):
        chi2_value = jnp.einsum(
            "i, ij, j", coefficient_values, self.incov_tot, coefficient_values
        )

        return chi2_value


class OptimalttLCF1000:
    def __init__(self, coefficients, rge_dict=None):
        self.rgemat, coefficients = rge_matrix_manager(
            coefficients, rge_dict, scale=1000.0
        )

        self.project = np.zeros((len(oo_tt_wc_basis), coefficients.size))
        for i, op in enumerate(oo_tt_wc_basis):
            if op in coefficients.name:
                self.project[i, np.argwhere(coefficients.name == op)[0, 0]] = 1

        self.datasets = {
            "LCF_tt_wbwb_1000_neg80_neg20": "invcov_LCF_tt_wbwb_1000_neg80_neg20.dat",
            "LCF_tt_wbwb_1000_pos80_neg20": "invcov_LCF_tt_wbwb_1000_pos80_neg20.dat",
            "LCF_tt_wbwb_1000_neg80_pos20": "invcov_LCF_tt_wbwb_1000_neg80_pos20.dat",
            "LCF_tt_wbwb_1000_pos80_pos20": "invcov_LCF_tt_wbwb_1000_pos80_pos20.dat",
        }

        incovs_reordered = []
        for path in self.datasets.values():
            invcov = np.loadtxt(current_file_path / path)
            temp = jnp.einsum("ij, jk, kl", self.project.T, invcov, self.project)
            incovs_reordered.append(temp)
        self.incov_tot = jnp.sum(jnp.array(incovs_reordered), axis=0)

        self.rgemat = rgemat

        if self.rgemat is not None:
            # multiply the RGE matrix as well
            self.incov_tot = jnp.einsum(
                "ij, jk, kl", self.rgemat.T, self.incov_tot, self.rgemat
            )

        self.n_dat = len(oo_tt_wc_basis)

    def compute_chi2(self, coefficient_values):
        chi2_value = jnp.einsum(
            "i, ij, j", coefficient_values, self.incov_tot, coefficient_values
        )

        return chi2_value
