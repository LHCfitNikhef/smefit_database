import numpy as np
import pathlib
import jax.numpy as jnp
from smefit import log
from smefit.rge.rge import RGE
from smefit.coefficients import CoefficientManager

current_file_path = pathlib.Path(__file__).resolve().parent

oo_ww_wc_basis = ["OpD", "OpWB", "OWWW", "Opl1", "Ope", "O3pl1"]

_logger = log.logging.getLogger(__name__)


def compute_rge_matrix(coefficients, rge_dict, scale):
    rge_runner = RGE(
        wc_names=coefficients.name,
        init_scale=rge_dict["init_scale"],
        accuracy=rge_dict.get("smeft_accuracy", "integrate"),
        adm_QCD=rge_dict.get("adm_QCD", False),
        yukawa=rge_dict.get("yukawa", "top"),
    )
    rge_df = rge_runner.RGEmatrix(scale)
    gen_operators = list(rge_df.index)
    _logger.info("The operators generated by the RGE are: ")
    _logger.info(gen_operators)
    operators_dict = {k: {"max": 0.0, "min": 0.0} for k in gen_operators}
    new_coeffs = CoefficientManager.from_dict(operators_dict)

    return rge_df.values, new_coeffs


class OptimalWW_LEP3_161:
    def __init__(self, coefficients, rge_dict=None):
        if rge_dict is not None:
            rgemat, coefficients = compute_rge_matrix(
                coefficients, rge_dict, scale=161.0
            )
        else:
            rgemat = None

        self.project = np.zeros((len(oo_ww_wc_basis), coefficients.size))
        for i, op in enumerate(oo_ww_wc_basis):
            if op in coefficients.name:
                self.project[i, np.argwhere(coefficients.name == op)[0, 0]] = 1

        self.datasets = {
            "LEP3_ww_lepto_161": "invcov_LEP3_ww_leptonic_161.dat",
            "LEP3_ww_semilep_161": "invcov_LEP3_ww_semilep_161.dat",
        }

        incovs_reordered = []
        for path in self.datasets.values():
            invcov = np.loadtxt(current_file_path / path)
            temp = jnp.einsum("ij, jk, kl", self.project.T, invcov, self.project)
            incovs_reordered.append(temp)
        self.incov_tot = jnp.sum(jnp.array(incovs_reordered), axis=0)

        # FCCee (161): 19200 ab-1
        # LEP3 (161): 5600 ab-1
        self.incov_tot *= 5600 / 19200

        self.rgemat = rgemat

        if self.rgemat is not None:
            # multiply the RGE matrix as well
            self.incov_tot = jnp.einsum(
                "ij, jk, kl", self.rgemat.T, self.incov_tot, self.rgemat
            )

        self.n_dat = len(oo_ww_wc_basis)

    def compute_chi2(self, coefficient_values):
        chi2_value = jnp.einsum(
            "i, ij, j", coefficient_values, self.incov_tot, coefficient_values
        )

        return chi2_value


class OptimalWW_LEP3_240:
    def __init__(self, coefficients, rge_dict=None):
        if rge_dict is not None:
            rgemat, coefficients = compute_rge_matrix(
                coefficients, rge_dict, scale=240.0
            )
        else:
            rgemat = None

        self.project = np.zeros((len(oo_ww_wc_basis), coefficients.size))
        for i, op in enumerate(oo_ww_wc_basis):
            if op in coefficients.name:
                self.project[i, np.argwhere(coefficients.name == op)[0, 0]] = 1

        self.datasets = {
            "LEP3_ww_lepto_240": "invcov_LEP3_ww_leptonic_240.dat",
            "LEP3_ww_semilep_240": "invcov_LEP3_ww_semilep_240.dat",
        }

        incovs_reordered = []
        for path in self.datasets.values():
            invcov = np.loadtxt(current_file_path / path)
            temp = jnp.einsum("ij, jk, kl", self.project.T, invcov, self.project)
            incovs_reordered.append(temp)
        self.incov_tot = jnp.sum(jnp.array(incovs_reordered), axis=0)

        # rescale invcov_tot by luminosity ratio starting from FCCee
        # FCCee (240): 10800 ab-1
        # LEP3 (240): 2304 ab-1
        self.incov_tot *= 2304 / 10800

        self.rgemat = rgemat

        if self.rgemat is not None:
            # multiply the RGE matrix as well
            self.incov_tot = jnp.einsum(
                "ij, jk, kl", self.rgemat.T, self.incov_tot, self.rgemat
            )

        self.n_dat = len(oo_ww_wc_basis)

    def compute_chi2(self, coefficient_values):
        chi2_value = jnp.einsum(
            "i, ij, j", coefficient_values, self.incov_tot, coefficient_values
        )

        return chi2_value
